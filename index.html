<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Four Houses</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            overflow: hidden;
            color: white;
            font-family: 'Poppins', sans-serif;
        } 

        .diamond-info span {
            position: absolute;
            color: white;
            text-shadow: 1px 1px 2px black;
            text-align: center;
        }

        .main-text {
            font-size: 3rem;
            transition: transform 0.3s ease;
            cursor: pointer;
        }

        .details {
            font-size: 1rem;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .diamond-info span:hover .details {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="diamond-container">
        <div class="diamond-info" id="ruby-info">
            <span id="ruby-text"></span>
        </div>
        <div class="diamond-info" id="amber-info">
            <span id="amber-text"></span>
        </div>
        <div class="diamond-info" id="emerald-info">
            <span id="emerald-text"></span>
        </div>
        <div class="diamond-info" id="sapphire-info">
            <span id="sapphire-text"></span>
        </div>
    </div>

    <script src="https://threejsfundamentals.org/threejs/resources/threejs/r127/build/three.min.js"></script>
    <script src="https://threejsfundamentals.org/threejs/resources/threejs/r127/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Animation function for counting up numbers
        function animateValue(start, end, duration, callback) {
            const startTime = performance.now();
            
            function update() {
                const currentTime = performance.now();
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function for smooth animation
                const easeOutQuad = t => t * (2 - t);
                const easedProgress = easeOutQuad(progress);
                
                const current = Math.floor(start + (end - start) * easedProgress);
                callback(current);

                if (progress < 1) {
                    requestAnimationFrame(update);
                }
            }
            
            update();
        }

        class DiamondShape {
            constructor(color) {
                this.color = color;
                this.mesh = this.createDiamondMesh();
            }

            createDiamondMesh() {
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const indices = [];

                const midVertices = 6;
                const radius = 1;
                const angleStep = (2 * Math.PI) / midVertices;

                const bottomPoint = [0, -1, 0];
                const topCenter = [0, 0.4, 0];
                const midPoints = [];
                const topPoints = [];

                for (let i = 0; i < midVertices; i++) {
                    const angle = i * angleStep;
                    midPoints.push([radius * Math.cos(angle), 0, radius * Math.sin(angle)]);
                    topPoints.push([0.5 * Math.cos(angle), 0.4, 0.5 * Math.sin(angle)]);
                }

                vertices.push(...bottomPoint);
                midPoints.forEach(point => vertices.push(...point));
                topPoints.forEach(point => vertices.push(...point));
                vertices.push(...topCenter);

                const bottomIndex = 0;
                const topCenterIndex = vertices.length / 3 - 1;

                for (let i = 0; i < midVertices; i++) {
                    const next = (i + 1) % midVertices;
                    indices.push(bottomIndex, i + 1, next + 1);
                    indices.push(i + 1, midVertices + 1 + i, midVertices + 1 + next);
                    indices.push(i + 1, midVertices + 1 + next, next + 1);
                    indices.push(midVertices + 1 + next, midVertices + 1 + i, topCenterIndex);
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();

                const colors = new Float32Array(vertices.length);
                for (let i = 0; i < vertices.length / 3; i++) {
                    const baseColor = new THREE.Color(this.color);
                    baseColor.offsetHSL(Math.random() * 0.1 - 0.05, 0, Math.random() * 0.1 - 0.05);
                    colors.set(baseColor.toArray(), i * 3);
                }

                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const material = new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    shininess: 150,
                    specular: 0xffffff,
                    transparent: true,
                    flatShading: true,
                    opacity: 0.75
                });

                return new THREE.Mesh(geometry, material);
            }
        }

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Create diamonds with colors and positions
        const diamonds = [
            { color: 0xff0000, position: [-2, 2, 0] }, // Ruby
            { color: 0xffbf00, position: [0, 2, 0] },  // Amber
            { color: 0x00ff00, position: [2, 2, 0] },  // Emerald
            { color: 0x0000ff, position: [4, 2, 0] }   // Sapphire
        ];

        diamonds.forEach(({ color, position }) => {
            const diamond = new DiamondShape(color);
            diamond.mesh.position.set(...position);
            scene.add(diamond.mesh);
        });

        // Lighting
        const light1 = new THREE.PointLight(0xffffff, 9.5, 50);
        light1.position.set(5, 5, 5);
        scene.add(light1);

        const light2 = new THREE.PointLight(0xffffff, 2.7, 50);
        light2.position.set(-5, 5, -5);
        scene.add(light2);

        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        // Camera controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        camera.position.set(0, 1, 5);
        controls.update();

        // Houses data
        const housesData = {
            ruby: { name: 'Ruby', year7: 2893, year8: 3164, year9: 3160, year10: 2631, year11: 2725 },
            amber: { name: 'Amber', year7: 2623, year8: 2654, year9: 2430, year10: 3026, year11: 2288 },
            emerald: { name: 'Emerald', year7: 3069, year8: 3232, year9: 2835, year10: 2755, year11: 2201 },
            sapphire: { name: 'Sapphire', year7: 2698, year8: 3233, year9: 2485, year10: 3031, year11: 2355 }
        };

        // Calculate totals for each house
        Object.keys(housesData).forEach(house => {
            const data = housesData[house];
            data.wholeTotal = data.year7 + data.year8 + data.year9 + data.year10 + data.year11;
        });

        // Update span text with all year groups
        function updateDiamondInfo() {
            Object.keys(housesData).forEach(house => {
                const info = housesData[house];
                const textElement = document.getElementById(`${house}-text`);
                
                // Create main text and details containers
                textElement.innerHTML = `
                    <div class="main-text">
                        ${info.name}<br>
                        <span id="${house}-total">0</span>
                    </div>
                    <div class="details"><br><br><br>
                        Y7: ${info.year7}<br>
                        Y8: ${info.year8}<br>
                        Y9: ${info.year9}<br>
                        Y10: ${info.year10}<br>
                        Y11: ${info.year11}
                    </div>`;

                // Animate the total value
                animateValue(0, info.wholeTotal, 2000, (value) => {
                    document.getElementById(`${house}-total`).textContent = value;
                });
            });
        }

        // Position spans relative to diamonds
        function positionSpansRelativeToDiamonds() {
            const diamondsInfo = [
                { id: 'ruby-text', position: [-2, 2, 0] },
                { id: 'amber-text', position: [0, 2, 0] },
                { id: 'emerald-text', position: [2, 2, 0] },
                { id: 'sapphire-text', position: [4, 2, 0] }
            ];

            diamondsInfo.forEach(({ id, position }) => {
                const span = document.getElementById(id);
                const diamondPosition = new THREE.Vector3(...position);
                const canvasWidth = renderer.domElement.offsetWidth;
                const canvasHeight = renderer.domElement.offsetHeight;

                const projectedPosition = diamondPosition.clone().project(camera);

                const x = (projectedPosition.x * 0.5 + 0.5) * canvasWidth;
                const y = (1 - (projectedPosition.y * 0.5 + 0.5)) * canvasHeight;

                span.style.position = 'absolute';
                span.style.left = `${x}px`;
                span.style.top = `${y + 110}px`;
                span.style.transform = 'translateX(-50%)';
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            scene.traverse(object => {
                if (object.isMesh) object.rotation.y += 0.01;
            });
            controls.update();
            renderer.render(scene, camera);
            positionSpansRelativeToDiamonds();
        }

        // Handle resizing
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            positionSpansRelativeToDiamonds();
        });

        // Initial setup
        updateDiamondInfo();
        animate();
    </script>
</body>
</html>
