<!DOCTYPE html> 
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Rotating Plumbobs with House Points</title>
    <!-- Import Harry Potter-like Font from Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* General Styles */
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Cinzel', serif; /* Harry Potter-like font */
            position: relative;
            background-color: #00023b; /* Match Three.js background */
        }

        /* 3D Canvas */
        #three-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0; /* Background layer */
        }

        /* Overlay Button Container */
        .overlay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3; /* Above Three.js canvas */
            display: flex;
            gap: 10px;
        }

        /* Harry Potter-like Button Styling */
        .overlay button {
            font-family: 'Cinzel', serif;
            font-size: 16px;
            padding: 10px 20px;
            background-color: #3c1e1e; /* Dark maroon */
            color: #e3b129; /* Light parchment-like color */
            border: 2px solid #8b4513; /* SaddleBrown border */
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .overlay button:hover {
            background-color: #5a2a2a; /* Lighter maroon on hover */
            transform: scale(1.05);
        }

        .overlay button.active {
            background-color: #8b4513; /* Highlight active button */
            color: #fff;
        }

        /* Label Styling */
        .plumbob-label {
            position: absolute;
            color: #f0e6d2; /* Light parchment-like color */
            font-size: 27px;
            pointer-events: none;
            transform: translate(-50%, -50%);
            white-space: nowrap;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 4; /* Above buttons */
            font-family: 'Cinzel', serif;
        }
    </style>
</head>
<body>
    <!-- 3D Scene Canvas -->
    <div id="three-canvas"></div>

    <!-- Overlay Buttons for Category Selection -->
    <div class="overlay">
        <button onclick="displayCategoryPoints('year7')">Y7</button>
        <button onclick="displayCategoryPoints('year8')">Y8</button>
        <button onclick="displayCategoryPoints('year9')">Y9</button>
        <button onclick="displayCategoryPoints('year10')">Y10</button>
        <button onclick="displayCategoryPoints('year11')">Y11</button>
        <button onclick="displayCategoryPoints('ks3Total')">KS3</button>
        <button onclick="displayCategoryPoints('ks4Total')">KS4</button>
        <button onclick="displayCategoryPoints('wholeTotal')">Total</button>
    </div>

    <!-- Plumbob Labels Container -->
    <div id="labels-container"></div>

    <!-- Three.js, OrbitControls, and GSAP Libraries -->
    <script src="https://threejsfundamentals.org/threejs/resources/threejs/r127/build/three.min.js"></script>
    <!-- OrbitControls r127 -->
    <script src="https://threejsfundamentals.org/threejs/resources/threejs/r127/examples/js/controls/OrbitControls.js"></script>
    <!-- GSAP Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script>
        // === House Data and Management ===
        // Function to log camera statistics
        function consoleLogCameraStatsRealtime() {
            console.log("Camera Position:", camera.position);
            console.log("Camera Rotation:", camera.rotation);
            console.log("Camera FOV:", camera.fov);
            console.log("Camera Aspect Ratio:", camera.aspect);
            console.log("Camera Near Clipping Plane:", camera.near);
            console.log("Camera Far Clipping Plane:", camera.far);
        }

        // Initial Data
        const housesData = {
            emerald: {
                name: 'Emerald',
                year7: 3069,
                year8: 3232,
                year9: 2835,
                year10: 2755,
                year11: 2201,
                ks3Total: 0,
                ks4Total: 0,
                wholeTotal: 0
            },
            sapphire: {
                name: 'Sapphire',
                year7: 2698,
                year8: 3233,
                year9: 2485,
                year10: 3031,
                year11: 2355,
                ks3Total: 0,
                ks4Total: 0,
                wholeTotal: 0
            },
            ruby: {
                name: 'Ruby',
                year7: 2893,
                year8: 3164,
                year9: 3160,
                year10: 2631,
                year11: 2725,
                ks3Total: 0,
                ks4Total: 0,
                wholeTotal: 0
            },
            ember: {
                name: 'Ember',
                year7: 2623,
                year8: 2654,
                year9: 2430,
                year10: 3026,
                year11: 2288,
                ks3Total: 0,
                ks4Total: 0,
                wholeTotal: 0
            }
        };

        // Function to calculate totals
        function calculateTotals(house) {
            const ks3Total = house.year7 + house.year8 + house.year9;
            const ks4Total = house.year10 + house.year11;
            const wholeTotal = ks3Total + ks4Total;
            return { ks3Total, ks4Total, wholeTotal };
        }

        // Initialize totals
        function initializeTotals() {
            for (let house of Object.values(housesData)) {
                Object.assign(house, calculateTotals(house));
            }
        }

        // Initialize totals and render initial state
        initializeTotals();

        // === Three.js Scene Setup ===

        // Create the scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color('#00023b'); // Dark blue background to match CSS

        // === Camera Configuration ===
        // Create the camera with specified settings
        const camera = new THREE.PerspectiveCamera(
            75, // Camera FOV
            window.innerWidth / window.innerHeight, // Responsive aspect ratio
            0.1, // Camera Near Clipping Plane
            1000 // Camera Far Clipping Plane (increased for better star visibility)
        );

        // Set Camera Position
        camera.position.set(-4.504709190194012, 2.3614634543782396, 3.759133605688632);

        // Set Camera Rotation
        camera.rotation.order = 'XYZ'; // Ensure rotation order matches the provided data
        camera.rotation.set(
            -0.5608924995077641, // _x rotation in radians
            -0.7927085460529486, // _y rotation in radians
            -0.4207190625003154  // _z rotation in radians
        );

        // Create the renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('three-canvas').appendChild(renderer.domElement); // Append renderer to the DOM

        // Add OrbitControls for interactive camera movement
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Enable damping for smooth controls
        controls.dampingFactor = 0.05;

        // === Lighting Setup ===

        // Ambient light for general illumination
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Soft white light
        scene.add(ambientLight);

        // Point light for specular highlights and depth
        const pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(10, 20, 10); // Position the light above and to the side
        scene.add(pointLight);

        // === Starfield Setup ===

        // Create a texture for circular stars using Canvas
        function createStarTexture() {
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');

            // Draw a white circle
            context.beginPath();
            context.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2, false);
            context.closePath();

            // Create radial gradient for smooth edges
            const gradient = context.createRadialGradient(size / 2, size / 2, size / 2, size / 2, size / 2, 0);
            gradient.addColorStop(0.0, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.6)');
            gradient.addColorStop(0.4, 'rgba(255,255,255,1)');
            gradient.addColorStop(1.0, 'rgba(255,255,255,1)');
            context.fillStyle = gradient;
            context.fill();

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        const starTexture = createStarTexture();

        // Create a geometry to hold all star positions
        const starGeometry = new THREE.BufferGeometry();
        const starCount = 5000; // Increased number of stars for a denser background
        const starPositions = [];

        for (let i = 0; i < starCount; i++) {
            const x = THREE.MathUtils.randFloatSpread(1000); // Adjusted spread for movement
            const y = THREE.MathUtils.randFloatSpread(1000);
            const z = THREE.MathUtils.randFloatSpread(1000);
            starPositions.push(x, y, z);
        }

        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));

        // Create a Points material for stars
        const starMaterial = new THREE.PointsMaterial({
            map: starTexture, // Assign the circular star texture
            size: 2, // Increased star size
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.8,
            depthWrite: false, // Prevent stars from occluding other objects
            blending: THREE.AdditiveBlending // Enhance star brightness
        });

        // Create the Points object and add to the scene
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // === Shooting Stars Setup ===

        class ShootingStar {
            constructor() {
                const geometry = new THREE.SphereGeometry(1, 8, 8); // Slightly larger for visibility
                const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
                this.mesh = new THREE.Mesh(geometry, material);

                // Initialize position at a random left edge
                const edge = Math.floor(Math.random() * 2); // 0 for left, 1 for top
                const range = 500; // Adjusted range for visibility
                if (edge === 0) { // Left
                    this.mesh.position.set(-range, THREE.MathUtils.randFloatSpread(200), THREE.MathUtils.randFloatSpread(200));
                } else { // Top
                    this.mesh.position.set(THREE.MathUtils.randFloatSpread(200), THREE.MathUtils.randFloatSpread(200), THREE.MathUtils.randFloatSpread(200));
                }

                // Set velocity towards the right (left to right)
                const direction = new THREE.Vector3(1, 0, 0).normalize(); // Move along positive X-axis
                this.velocity = direction.multiplyScalar(15 + Math.random() * 10); // Faster speed

                this.lifetime = 0;
                this.maxLifetime = 60; // Frames
                scene.add(this.mesh);
            }

            update() {
                this.mesh.position.add(this.velocity);
                this.lifetime++;
            }

            isExpired() {
                return this.lifetime > this.maxLifetime;
            }

            dispose() {
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        const shootingStars = [];
        const maxShootingStars = 10; // Increased maximum shooting stars
        const shootingStarInterval = 1000; // Reduced interval for more frequent shooting stars

        function createShootingStar() {
            if (shootingStars.length >= maxShootingStars) return;
            const star = new ShootingStar();
            shootingStars.push(star);
        }

        // Periodically create shooting stars
        setInterval(createShootingStar, shootingStarInterval);

        // === Plumbob Class ===

        class Plumbob {
            constructor(size = 1, borderThickness = 0.05, rotationSpeed = 0.005, color = '#00ff00') {
                this.size = size;
                this.borderThickness = borderThickness;
                this.rotationSpeed = rotationSpeed;
                this.color = color;

                // Create a group to hold the Plumbob components
                this.group = new THREE.Group();
                this.group.scale.set(this.size, this.size, this.size);

                // Material for the Plumbob (reflective and transparent)
                this.material = new THREE.MeshPhongMaterial({
                    color: new THREE.Color(this.color),
                    specular: 0xffffff,
                    shininess: 50,
                    opacity: 0.76,
                    transparent: true,
                    flatShading: false
                });

                // Geometry and Mesh for the top cone
                const topConeGeometry = new THREE.ConeGeometry(0.5, 1, 4);
                this.topCone = new THREE.Mesh(topConeGeometry, this.material);
                this.topCone.rotation.y = Math.PI / 4; // Diamond-like rotation
                this.group.add(this.topCone);

                // Geometry and Mesh for the bottom cone
                const bottomConeGeometry = new THREE.ConeGeometry(0.5, 1, 4);
                this.bottomCone = new THREE.Mesh(bottomConeGeometry, this.material);
                this.bottomCone.rotation.x = Math.PI; // Flip upside down
                this.bottomCone.rotation.y = Math.PI / 4;
                this.bottomCone.position.y = -1; // Offset below the top cone
                this.group.add(this.bottomCone);
            }

            /**
             * Adds the Plumbob to the provided Three.js group.
             * @param {THREE.Group} group - The Three.js group to add the Plumbob to.
             */
            addToGroup(group) {
                group.add(this.group);
            }

            /**
             * Updates the rotation of the Plumbob.
             */
            update() {
                this.group.rotation.y += this.rotationSpeed;
            }
        }

        // Function to create a plumbob label
        function createPlumbobLabel() {
            const label = document.createElement('div');
            label.className = 'plumbob-label';
            document.getElementById('labels-container').appendChild(label); // Append to labels-container
            return label;
        }

        // === Create a Parent Group for All Plumbobs ===
        const plumbobGroup = new THREE.Group();
        scene.add(plumbobGroup);

        // === Create Plumbobs ===

        // Helper function to generate a slight random rotation speed
        function getRandomRotationSpeed(baseSpeed) {
            return baseSpeed + (Math.random() - 0.5) * 0.002; // Slight variation
        }

        // Instantiate four Plumbobs with different colors and slightly random rotation speeds
        const plumbobRed = new Plumbob(2, 0.01, getRandomRotationSpeed(0.005), 'red');
        plumbobRed.addToGroup(plumbobGroup);
        plumbobRed.group.position.set(-4, 2, 0); // Initial position (will be updated dynamically)

        const plumbobYellow = new Plumbob(2, 0.01, getRandomRotationSpeed(0.005), 'yellow');
        plumbobYellow.addToGroup(plumbobGroup);
        plumbobYellow.group.position.set(-1.33, 2, 0); // Initial position (will be updated dynamically)

        const plumbobGreen = new Plumbob(2, 0.01, getRandomRotationSpeed(0.005), 'green');
        plumbobGreen.addToGroup(plumbobGroup);
        plumbobGreen.group.position.set(1.33, 2, 0); // Initial position (will be updated dynamically)

        const plumbobBlue = new Plumbob(2, 0.01, getRandomRotationSpeed(0.005), 'blue');
        plumbobBlue.addToGroup(plumbobGroup);
        plumbobBlue.group.position.set(4, 2, 0); // Initial position (will be updated dynamically)

        // Store Plumbob instances in an array with their corresponding keys, labels, and movement parameters
        const plumbobs = [
            { 
                plumbob: plumbobRed, 
                key: 'ruby', 
                label: createPlumbobLabel(), 
                phase: Math.random() * Math.PI * 2, 
                amplitude: 0.2, 
                baseY: 2,
                targetX: plumbobRed.group.position.x, // Initialize target positions
                targetY: plumbobRed.group.position.y
            },
            { 
                plumbob: plumbobYellow, 
                key: 'ember', 
                label: createPlumbobLabel(), 
                phase: Math.random() * Math.PI * 2, 
                amplitude: 0.2, 
                baseY: 2,
                targetX: plumbobYellow.group.position.x,
                targetY: plumbobYellow.group.position.y
            },
            { 
                plumbob: plumbobGreen, 
                key: 'emerald', 
                label: createPlumbobLabel(), 
                phase: Math.random() * Math.PI * 2, 
                amplitude: 0.2, 
                baseY: 2,
                targetX: plumbobGreen.group.position.x,
                targetY: plumbobGreen.group.position.y
            },
            { 
                plumbob: plumbobBlue, 
                key: 'sapphire', 
                label: createPlumbobLabel(), 
                phase: Math.random() * Math.PI * 2, 
                amplitude: 0.2, 
                baseY: 2,
                targetX: plumbobBlue.group.position.x,
                targetY: plumbobBlue.group.position.y
            }
        ];

        // === Animation Parameters ===

        let initialAnimation = true; // Flag to control initial group rotation animation
        const initialAnimationDuration = 2000; // 2 seconds in milliseconds
        const initialStartTime = Date.now();

        // Define group rotation parameters for GSAP
        const initialRotation = {
            y: plumbobGroup.rotation.y
        };

        const finalRotation = {
            y: plumbobGroup.rotation.y + Math.PI * 4 // Rotate 4 half-turns (2 full turns)
        };

        // Start the initial rotation with GSAP
        gsap.to(initialRotation, {
            y: finalRotation.y,
            duration: 2, // 2 seconds
            ease: "power2.out",
            onUpdate: () => {
                plumbobGroup.rotation.y = initialRotation.y;
            },
            onComplete: () => {
                initialAnimation = false; // Stop further rotations after initial animation
            }
        });

        // === Animation Loop ===

        function animate() {
            requestAnimationFrame(animate);

            // Update Shooting Stars
            for (let i = shootingStars.length - 1; i >= 0; i--) {
                const star = shootingStars[i];
                star.update();
                if (star.isExpired()) {
                    star.dispose();
                    shootingStars.splice(i, 1);
                }
            }

            // Update Starfield: Move stars right
            const positions = starGeometry.attributes.position.array;
            const speed = 1; // Adjust speed as needed

            for (let i = 0; i < positions.length; i += 3) {
                positions[i] += speed; // Move right along the X-axis

                // If star moves beyond right boundary, reset to the left
                if (positions[i] > 500) { // Adjust boundary as per star spread
                    positions[i] = -500; // Reset to the left
                    positions[i + 1] = THREE.MathUtils.randFloatSpread(1000); // Random Y
                    positions[i + 2] = THREE.MathUtils.randFloatSpread(1000); // Random Z
                }
            }

            // Inform Three.js that positions have been updated
            starGeometry.attributes.position.needsUpdate = true;

            // Current time in seconds for sine wave calculation
            const timeInSeconds = Date.now() * 0.001;

            // Update each Plumbob's rotation and position
            plumbobs.forEach(item => {
                item.plumbob.update();

                // Update y-position based on sine wave with unique phase
                item.plumbob.group.position.y = item.baseY + item.amplitude * Math.sin(timeInSeconds + item.phase);
            });

            // Update OrbitControls
            controls.update();

            // Update and position labels
            plumbobs.forEach(item => {
                const pos = new THREE.Vector3();
                item.plumbob.group.getWorldPosition(pos);
                pos.project(camera);

                const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;

                item.label.style.left = `${x}px`;
                item.label.style.top = `${y + 220}px`; // Position below the Plumbob

                // Show or hide the label based on whether it has content
                if (item.label.innerHTML) {
                    item.label.style.display = 'block';
                } else {
                    item.label.style.display = 'none';
                }
            });

            // Render the scene from the camera's perspective
            renderer.render(scene, camera);
        }

        animate(); // Start the animation loop

        // === Handle Window Resize ===

        window.addEventListener('resize', () => {
            // Update camera aspect ratio and projection matrix
            camera.aspect = window.innerWidth / window.innerHeight; // This maintains responsiveness
            camera.updateProjectionMatrix();

            // Update renderer size
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // === Handling Button Clicks to Display Points on Plumbobs ===

        // Function to display points for a specific category on Plumbobs
        function displayCategoryPoints(category) {
            // Remove 'active' class from all buttons
            const buttons = document.querySelectorAll('.overlay button');
            buttons.forEach(btn => btn.classList.remove('active'));

            // Add 'active' class to the clicked button
            event.currentTarget.classList.add('active');

            // Array to hold plumbobs with their respective points
            const plumbobsWithPoints = plumbobs.map(item => {
                const house = housesData[item.key];
                let points = house[category];

                // Handle cases where totals might not be defined
                if (points === undefined || points === null) {
                    points = 0;
                }

                return { ...item, points };
            });

            // Sort plumbobs based on points in descending order
            plumbobsWithPoints.sort((a, b) => b.points - a.points);

            // Define new x positions based on sorted order
            const totalPlumbobs = plumbobsWithPoints.length;
            const spacing = 8; // Total width span (from -4 to +4)
            const startX = -spacing / 2;
            const interval = spacing / (totalPlumbobs - 1);

            plumbobsWithPoints.forEach((item, index) => {
                const newX = startX + interval * index;

                // Update label with bold points
                item.label.innerHTML = `${housesData[item.key].name}<br><strong>${item.points}</strong>`;

                // Use GSAP to tween the plumbob's x position to newX
                gsap.to(item.plumbob.group.position, {
                    x: newX,
                    duration: 1, // 1 second
                    ease: "power2.out"
                });
            });
        }

        // Function to clear all Plumbob labels
        function clearPlumbobLabels() {
            plumbobs.forEach(item => {
                item.label.innerHTML = '';
            });
        }

        // Trigger the default selection ('Total') on page load
        // Since the script is at the end of the body, the DOM is already loaded
        window.onload = function() {
            // Simulate a click on the 'Total' button to initialize
            const totalButton = document.querySelector('.overlay button:last-child');
            if (totalButton) {
                totalButton.click();
            }
        };
    </script>
</body>
</html>
